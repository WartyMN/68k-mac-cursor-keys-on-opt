/* * app.c * *  Created on: May 4, 2025 *      Author: micahbly *//*****************************************************************************//*                                Includes                                   *//*****************************************************************************/// project includes#include "badge.h"// C includes// Platform includes#include <Events.h>#include <Fonts.h>#include <Icons.h>#include <Memory.h>#include <OSUtils.h>#include <QuickDraw.h>#include <Resources.h>#include <SetUpA4.h>#include <Traps.h>#include <Types.h>/*****************************************************************************//*                               Definitions                                 *//*****************************************************************************/#define kGetMainDeviceTrapNum	0xAA2A#define kUnimplementedTrapNum	0x9F//#define WaitNextEventTrap 0xA860	// this is not in the mac plus ROM!#define GetNextEventTrap 0xA970		// use this instead, as it is in mac plus rom and later roms.#define MASK_FOR_BOTH_OPTION_KEYS		0x4800 // bits for both right option 0x4000 and general options 0x0800. Probably overkill, as mac plus doesn't seem to distinguish between left/right/both.#define ICON_ID							-16455	// the ID of the ICN# in rsrc file we want to show at startup/*****************************************************************************//*                             Global Variables                              *//*****************************************************************************/Boolean					global_color_qd_available;Boolean					global_bw_only;		// color QD doesn't necessarily mean color availablestatic long				gOrigGetNextEvent;	// address of original GetNextEventstatic long				gOrigInitWindows;static unsigned char	global_last_mapped_key = 0;	// last key remapped; for auto repeatstatic Boolean			global_last_event_was_a_remap = false;/*****************************************************************************//*                       Private Function Prototypes                         *//*****************************************************************************/// ****** APP STARTUP// Patch the system's call to init windows to also call our badge displaypascal void App_PatchedInitWindows(void);// Call the toolbox initialization routines.void App_InitManagers(void);// Check what hardware we have available// chiefly we are checking for color displayvoid App_DetectEnvironment(void);// ****** APP EXECUTION// Checks event for keydown events where option key is held down, and modifies //   the key/charcode if one of our replacement cursor keys before handing //   control back to the original ROM event handler//! @param	the_event_mask – Pass through from the system, is not modified in this function//! @param	the_event – Pass through from the system. The message will be modified if the conditions are met and keys are remapped//! @return	Returns true/false passed through from the original get next event functionpascal Boolean NewGetNextEvent(short the_event_mask, EventRecord* the_event);// ****** APP SHUT DOWN/*****************************************************************************//*                       Private Function Definitions                        *//*****************************************************************************/// ****** APP STARTUP// Patch the system's call to init windows to also call our badge displaypascal void App_PatchedInitWindows(void){    // Establish context for this INIT's globals    SetUpA4();SysBeep(1);	// this will fire, so it's at least getting to hear before crashing mac.    // Now it's safe to access gOrigInitWindows and call Badge_Show	// First call the original InitWindows trap	CallPascal(gOrigInitWindows);SysBeep(1); // this will NOT fire, so it's dying before this presumably	// Then call your badge code (safe now!)	Badge_Show(ICON_ID);    // Restore the previous context    RestoreA4();}// Call the toolbox initialization routines.void App_InitManagers(void){	// LOGIC:	//   for this INIT, we only need QuickDraw. no other managers. 		InitGraf(&qd.thePort);}// Check what hardware and OS features we have availablevoid App_DetectEnvironment(void){	OSErr			err;	SysEnvRec		environsAnswer;	short			sysEnvironsVersionIexpect = 2;	//short myMachineType;	GDHandle		the_main_device;	/* use sysEnvirons to make assumptions about color vs patterns */	/* for more info, google "The System environment Record" in Inside Macintosh */	err = SysEnvirons(sysEnvironsVersionIexpect, &environsAnswer);	if(err != noErr)	{		/* got error just checking, so take most conservative approach. */		global_color_qd_available = 0;		return;	}		//myMachineType = environsAnswer.machineType;	// do nothing just yet, but for future, can use envMacIIfx, envMacPlus, etc. with this answer	// is Color QuickDraw available? Not guaranteed to be reliable indication of color vs B/W, because monitor might be B/W	global_color_qd_available = environsAnswer.hasColorQD;		// check main device to see if it's in color or B/W. this we CAN rely on (except in case of multiple-monitor setup)	// first have to check if GetMainDevice trap is even available (first appeared in 256K ROMs)	if (NGetTrapAddress(kGetMainDeviceTrapNum, ToolTrap) != NGetTrapAddress(kUnimplementedTrapNum, ToolTrap))	{		the_main_device = GetMainDevice();		global_bw_only = ( (**((**the_main_device).gdPMap)).pixelSize == 1 );	}	else	{		// assumption: if the machine only has 128k ROM, it doesn't have color.		global_bw_only = true;	}}// ****** APP EXECUTION// Checks event for keydown events where option key is held down, and modifies //   the key/charcode if one of our replacement cursor keys before handing //   control back to the original ROM event handler//! @param	the_event_mask – Pass through from the system, is not modified in this function//! @param	the_event – Pass through from the system. The message will be modified if the conditions are met and keys are remapped//! @return	Returns true/false passed through from the original get next event functionpascal Boolean NewGetNextEvent(short the_event_mask, EventRecord* the_event){	long			modified_key = 0;	unsigned char	the_key;	Boolean			is_option_down;	Boolean			event_needs_action;	Boolean			is_repeat_of_last;	// LOGIC:	//   call original GetNextEvent()	//   if the event is a keydown event, inspect modifier. if not Option key, return	//   inspect the key. If [, ], \, or =, translate to a cursor key	//   before returning, remove option key from the modifiers, but do not clear them. 	//     this allows SHIFT-cursor-right etc.		SetUpA4();	// call original GetNextEvent	event_needs_action = CallPascalB(the_event_mask, the_event, gOrigGetNextEvent);	if (event_needs_action)	{		if (the_event->what == keyDown || the_event->what == autoKey)		{			is_option_down = ((the_event->modifiers & MASK_FOR_BOTH_OPTION_KEYS) > 0);		    the_key = (the_event->message & keyCodeMask) >> 8;			is_repeat_of_last = (the_key == global_last_mapped_key && global_last_event_was_a_remap);			if (is_option_down == true || is_repeat_of_last == true)		    {				switch(the_key)				{					// LOGIC:					//   mb 2025-05-03: I cannot recall why the 0x4D00 etc was there. 					//     it doesn't correspond to anything I can trace to. 					//     this code had other problems I needed to fix, so not sure it was even the code that did work for Capscursors.					//     the 0xXX1F, 1C, etc, is from page I-248 of Inside Macintosh					//     adding that made it work. I left the upper byte as is as it didn't seem to hurt anything										case 0x18:						// = key -> UP CURSOR						modified_key = 0x4D1E; // Mac Plus keyboard desired cursor key						break;											case 0x21:						// [ key -> LEFT CURSOR						modified_key = 0x461C; // 1c is left cursor char code						break;											case 0x1E:						// ] key -> DOWN CURSOR						modified_key = 0x481F; // Mac Plus keyboard desired cursor key						break;											case 0x2A:						// \ key -> RIGHT CURSOR						modified_key = 0x421D; // Mac Plus keyboard desired cursor key						break;										default:						// debug						modified_key = 0x00; // if not one of the above, we aren't interested.						break;								}							if (modified_key)				{					// re-mask by blanking out lower 2 bytes, preserving 3rd/4th byte					the_event->message = (the_event->message & 0xFFFF0000) | modified_key;					// clear the option modifier only, leaving any shift, control, etc.					// this means that essentially, you can't do option [, ], = or \. boohoo.										the_event->modifiers &= ~(MASK_FOR_BOTH_OPTION_KEYS);							global_last_mapped_key = the_key;					global_last_event_was_a_remap = true;				}			}			else			{				global_last_event_was_a_remap = false;			}		}	}		RestoreA4();		return event_needs_action;}/*****************************************************************************//*                        Public Function Definitions                        *//*****************************************************************************/// show badge, install patch, etc.void main(void){	Handle	myHandle;	Ptr		myPtr;	asm	{		move.l A0, myPtr	}		RememberA0();	SetUpA4();	if (Button() == false) 	{		myHandle = RecoverHandle(myPtr); 				DetachResource(myHandle);		// Patch GetNextEvent		gOrigGetNextEvent = NGetTrapAddress((int)GetNextEventTrap, ToolTrap);		NSetTrapAddress((long)NewGetNextEvent, (int)GetNextEventTrap, ToolTrap);		// Patch InitWindows so we know QuickDraw is ready		//gOrigInitWindows = NGetTrapAddress(_InitWindows, OSTrap);		//NSetTrapAddress((long)&App_PatchedInitWindows, _InitWindows, OSTrap);		gOrigInitWindows = NGetTrapAddress(_InitWindows, OSTrap);		NSetTrapAddress((long)&App_PatchedInitWindows, _InitWindows, OSTrap);		// We don’t call Badge_Show here anymore — it’s too early		// we just wait until system gets further along, then it will show our badge	}	RestoreA4();}