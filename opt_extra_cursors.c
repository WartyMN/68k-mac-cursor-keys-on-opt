#include <SetUpA4.h>#include <Traps.h>#include "cursors_show_icon.h"#define GetNextEventTrap 0xA970#define MASK_FOR_BOTH_OPTION_KEYS		0x0800 // 0b01010000 00000000 = bits for both right option 0x4000 and general options 0x0800#define ICON_ID							-16455	// the ID of the ICN# in rsrc file we want to show at startuplong origGetNextEvent; // address of original GetNextEventstatic unsigned char	gLRemappedKey = 0;static Boolean			gLastEventWasRemap = false;pascal Boolean NewGetNextEvent(short eventMask, EventRecord *theEvent);void main(void);// Replacement GetNextEvent//   Calls ToolBox GetNextEvent, modifies EventRecord.message if appropriatepascal Boolean NewGetNextEvent(short eventMask, EventRecord *theEvent){	long			modifiedKey = 0;	Boolean			eventNeedsAction;	unsigned char	theKey;	Boolean			isOption;	Boolean			isRepeatOfLast;	// LOGIC:	//   call original GetNextEvent()	//   if the event is a keydown event, inspect modifier. if not Option key, return	//   inspect the key. If [, ], \, or =, translate to a cursor key	//   before returning, remove option key from the modifiers, but do not clear them. 	//     this allows SHIFT-cursor-right etc.		SetUpA4();	// call original GetNextEvent	eventNeedsAction = CallPascalB(eventMask, theEvent, origGetNextEvent);	if (eventNeedsAction)	{		if (theEvent->what == keyDown || theEvent->what == autoKey)		{			isOption = ((theEvent->modifiers & MASK_FOR_BOTH_OPTION_KEYS) > 0);		    theKey = (theEvent->message & keyCodeMask) >> 8;			isRepeatOfLast = (theKey == gLRemappedKey && gLastEventWasRemap);			if (isOption == true || isRepeatOfLast == true)		    {				switch(theKey)				{					// LOGIC:					//   mb 2025-05-03: I cannot recall why the 0x4D00 etc was there. 					//     it doesn't correspond to anything I can trace to. 					//     this code had other problems I needed to fix, so not sure it was even the code that did work for Capscursors.					//     the 0xXX1F, 1C, etc, is from page I-248 of Inside Macintosh					//     adding that made it work. I left the upper byte as is as it didn't seem to hurt anything										case 0x18:						// = key -> UP CURSOR						modifiedKey = 0x4D1E; // Mac Plus keyboard desired cursor key						break;											case 0x21:						// [ key -> LEFT CURSOR						modifiedKey = 0x461C; // 1c is left cursor char code						break;											case 0x1E:						// ] key -> DOWN CURSOR						modifiedKey = 0x481F; // Mac Plus keyboard desired cursor key						break;											case 0x2A:						// \ key -> RIGHT CURSOR						modifiedKey = 0x421D; // Mac Plus keyboard desired cursor key						break;										default:						// debug						modifiedKey = 0x00; // if not one of the above, we aren't interested.						break;								}							if (modifiedKey)				{					// re-mask by blanking out lower 2 bytes, preserving 3rd/4th byte					theEvent->message = (theEvent->message & 0xFFFF0000) | modifiedKey;					// clear the option modifier only, leaving any shift, control, etc.					// this means that essentially, you can't do option [, ], = or \. boohoo.										theEvent->modifiers &= ~(MASK_FOR_BOTH_OPTION_KEYS);							gLRemappedKey = theKey;					gLastEventWasRemap = true;					//SysBeep(10);				}			}			else			{				gLastEventWasRemap = false;			}		}	}		RestoreA4();		return eventNeedsAction;}/* This block is called once. It saves the pointer to this code resource, and installs the patch. */void main(void){	Handle myHandle;	Ptr myPtr;	SysEnvRec world;	Str255 *namePtr;	asm	{		move.l A0, myPtr	}	 	RememberA0(); 	SetUpA4(); 	 	if(!Button())  	{ 		myHandle = RecoverHandle(myPtr); 				DetachResource(myHandle); 		origGetNextEvent = NGetTrapAddress((int)GetNextEventTrap, ToolTrap);		NSetTrapAddress((long)NewGetNextEvent, (int)GetNextEventTrap, ToolTrap);				ShowInitIcon(ICON_ID, true);	}		RestoreA4();}